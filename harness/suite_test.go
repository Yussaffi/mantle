// Copyright The Mantle Authors and The Go Authors
// SPDX-License-Identifier: Apache-2.0

package harness

import (
	"testing"
)

func TestSuiteParallelism(t *testing.T) {
	const (
		add1 = 0
		done = 1
	)
	// Apply a series of calls to the Suite, checking state after each.
	type call struct {
		typ int // add1 or done
		// result from applying the call
		running int
		waiting int
		started bool
	}
	testCases := []struct {
		max int
		run []call
	}{{
		max: 1,
		run: []call{
			{typ: add1, running: 1, waiting: 0, started: true},
			{typ: done, running: 0, waiting: 0, started: false},
		},
	}, {
		max: 1,
		run: []call{
			{typ: add1, running: 1, waiting: 0, started: true},
			{typ: add1, running: 1, waiting: 1, started: false},
			{typ: done, running: 1, waiting: 0, started: true},
			{typ: done, running: 0, waiting: 0, started: false},
			{typ: add1, running: 1, waiting: 0, started: true},
		},
	}, {
		max: 3,
		run: []call{
			{typ: add1, running: 1, waiting: 0, started: true},
			{typ: add1, running: 2, waiting: 0, started: true},
			{typ: add1, running: 3, waiting: 0, started: true},
			{typ: add1, running: 3, waiting: 1, started: false},
			{typ: add1, running: 3, waiting: 2, started: false},
			{typ: add1, running: 3, waiting: 3, started: false},
			{typ: done, running: 3, waiting: 2, started: true},
			{typ: add1, running: 3, waiting: 3, started: false},
			{typ: done, running: 3, waiting: 2, started: true},
			{typ: done, running: 3, waiting: 1, started: true},
			{typ: done, running: 3, waiting: 0, started: true},
			{typ: done, running: 2, waiting: 0, started: false},
			{typ: done, running: 1, waiting: 0, started: false},
			{typ: done, running: 0, waiting: 0, started: false},
		},
	}}
	for i, tc := range testCases {
		suite := NewSuite(Options{Parallel: tc.max}, nil)
		for j, call := range tc.run {
			doCall := func(f func()) chan bool {
				done := make(chan bool)
				go func() {
					f()
					done <- true
				}()
				return done
			}
			started := false
			switch call.typ {
			case add1:
				signal := doCall(suite.waitParallel)
				select {
				case <-signal:
					started = true
				case suite.startParallel <- true:
					<-signal
				}
			case done:
				signal := doCall(suite.release)
				select {
				case <-signal:
				case <-suite.startParallel:
					started = true
					<-signal
				}
			}
			if started != call.started {
				t.Errorf("%d:%d:started: got %v; want %v", i, j, started, call.started)
			}
			if suite.running != call.running {
				t.Errorf("%d:%d:running: got %v; want %v", i, j, suite.running, call.running)
			}
			if suite.waiting != call.waiting {
				t.Errorf("%d:%d:waiting: got %v; want %v", i, j, suite.waiting, call.waiting)
			}
		}
	}
}
